{"meta":{"title":"WaiYe的个人博客","subtitle":null,"description":"希望能做成一个技术博客，一点一点积累（说不定还能提高一下写作能力）","author":"WaiYe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"基于canvas的简易粒子引擎","slug":"web","date":"2018-10-22T13:50:58.000Z","updated":"2018-10-23T10:15:56.469Z","comments":true,"path":"2018/10/22/web/","link":"","permalink":"http://yoursite.com/2018/10/22/web/","excerpt":"我发现动漫里面经常出现一个画面，早晨的阳光射进窗户，空气中漂浮着若隐若现的尘埃粒子 我就想试着在自己写主页添加粒子，让画面更加生动一点。","text":"我发现动漫里面经常出现一个画面，早晨的阳光射进窗户，空气中漂浮着若隐若现的尘埃粒子 我就想试着在自己写主页添加粒子，让画面更加生动一点。 先确定功能： 随机生成一定数量的粒子 粒子属性在一定范围内随机 粒子有生命周期（在刚生成时透明度高，慢慢越来越低，最后消失前透明度再次降低，看起来若隐若现） 粒子往鼠标汇聚 可以控制粒子系统的开启关闭 首先html里写上canvas标签 12&lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt;&lt;button id=\"buttonParticle\" type=\"button\" style=\"float: left;\"&gt;粒子开关&lt;/button&gt; 在css中大致写一下样式 12345678#canvas &#123; position: absolute; background-color: #363e47; display: block; left: 0; top: 0; z-index: -1; &#125; 然后就是最重要的js了,先创建canvas画布 12var canvas = document.getElementById(\"canvas\");var ctx = canvas.getContext(\"2d\"); 然后创建一个函数，将canvas的宽高设定为浏览器大小 12345//将canvas画布设置成浏览器大小function getSize() &#123; w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight;&#125; 接下来就是定义粒子了12345678910111213var opt = &#123; particleDelay: 10, //粒子生成延时 particleLife: 500, //粒子存活时间 particleAmount: 50, //粒子数量 defaultSpeed: 0.5, //粒子初始运动速度 variantSpeed: 1, //粒子运动速度改变量 defaultAlpha: 0.7, //粒子不透明度 variantAlpha: 0.3, //粒子不透明度改变量(0~1) particleColor: \"rgba(32,245,245,\", //粒子颜色 defaultRadius: 2, //粒子半径 variantRadius: 2, //粒子半径改变量 tractiveRange: 100, //鼠标牵引范围&#125; 粒子颜色这里因为后面要在生命周期函数里改变透明度，所以就先这样写着了粒子属性改变量是为了让每个粒子都不一样 然后就是初始化粒子,代码很长，我也写了很多注释，先把代码贴出来，后面再逐一解释12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function Particle() &#123; this.x = Math.random()*w; //粒子的x坐标 this.y = Math.random()*h; //粒子的y坐标 this.life = opt.particleLife; //粒子存活时间 this.currentLife = 0; //当前粒子存活时间 this.currentAlpha = 0; //当前粒子不透明度 this.alpha = opt.defaultAlpha - (Math.random() * opt.variantAlpha); //粒子不透明度 this.tempAlpha = (this.alpha/2) * (5/this.life); //按生存时间分割不透明度 this.speed = opt.defaultSpeed + opt.variantSpeed*Math.random(); //粒子运动速度 this.directionAngle = Math.floor(Math.random()*360); //返回一个0-360的整数 if (this.alpha &lt; 0) &#123; this.alpha = 0; &#125; this.radius = opt.defaultRadius + opt.variantRadius*Math.random(); //粒子半径 this.vector = &#123; x:this.speed * Math.cos(this.directionAngle), //x轴上的速度 y:this.speed * Math.sin(this.directionAngle) //y轴上的速度 &#125;; this.lifeUpdata = function () &#123; //生命周期函数 if (this.currentLife &lt;= (this.life / 4)) &#123; this.currentAlpha += this.tempAlpha; &#125;else if (this.currentLife &gt;= (this.life / 4) &amp;&amp; this.currentLife &lt;= (this.life * 3 / 4))&#123; this.currentAlpha = this.alpha; &#125; else if (this.currentLife &gt;= (this.life * 3 / 4)) &#123; this.currentAlpha -= this.tempAlpha; &#125; this.currentLife++; &#125;; this.updata = function () &#123; //更新数据 this.border(); //边缘检测 this.mouseTractive(); this.x += this.vector.x; this.y += this.vector.y; &#125;; this.border = function () &#123; //边缘检测 if (this.x + this.radius &gt;= w || this.x - this.radius &lt;= 0) &#123; //检测粒子触碰左右边界 this.vector.x *= -1; &#125; if (this.y + this.radius &gt;= h || this.y - this.radius &lt;= 0) &#123; //检测粒子触碰上下边界 this.vector.y *= -1; &#125; &#125;; this.draw = function () &#123; //绘制粒子 this.color = opt.particleColor + this.currentAlpha + \")\"; //粒子颜色 ctx.beginPath(); //开始一条路径 ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); //画圆 ctx.closePath(); ctx.fillStyle = this.color; ctx.fill(); //填充 ctx.shadowBlur = 20; //粒子阴影，做出边缘模糊的粒子 ctx.shadowColor = this.color; &#125;; this.mouseTractive = function () &#123; //鼠标牵引 mouseXY(); if (getDistance(this,mouse) &lt;= opt.tractiveRange) &#123; this.vector = &#123; x:this.speed * Math.cos(getTractiveAngle(this,mouse)), //x轴上的速度 y:this.speed * Math.sin(getTractiveAngle(this,mouse)) //y轴上的速度 &#125;; &#125; &#125;&#125; 粒子的坐标、初始速度、不透明度、半径都设置了一定量的随机 updata函数后面会放在window.requestAnimationFrame()方法中，可以理解为重复运行的代码块。 边缘检测是在粒子移动触碰到画布（浏览器）边缘时会反弹。其实这个函数可有可无，不过考虑到后面也许会用到所以就保留下来。 绘制粒子里的ctx.shadowBlur = 20和ctx.shadowColor = this.color是打算做出那种边缘模糊的粒子，不过亲测占用资源量大，在画布很多粒子的时候还是关掉比较好。 生命周期函数，前面已经设置了粒子的存活时间particleLife: 500和当前的存活时间(初始为0):this.currentLife = 0,每刷新一次，当前生命都会加1。 我将粒子的生命设置成4份，在前1/4的时候不透明度会从0开始递增，在生命2/4 ~ 3/4的生命中不透明度会固定在前面设置的不透明度：defaultAlpha: 0.7，然后最后的3/4生命不透明度会递减，最后到达0。 因为粒子有生命周期，所以必不可少的要定义生成粒子函数和清除粒子函数12345678910111213141516function remove() &#123; //清除粒子 for (var i = 0; i &lt; particle.length; i++) &#123; if (particle[i].currentLife &gt;= particle[i].life) particle.shift(); &#125;&#125;function createParticle() &#123; //生成粒子 if(particle.length &lt; opt.particleAmount) &#123; if(t &gt;= opt.particleDelay) &#123; particle.push(new Particle()); t = 0; &#125; t++; &#125;&#125; 定义一个函数用来获取鼠标坐标,window.onmousemove()会在鼠标移动时触发123456789101112var mouse = &#123; x: null, y: null&#125;;function mouseXY() &#123; window.onmousemove = function (e) &#123; //获取鼠标坐标 e = e || window.event; mouse.x = e.clientX; mouse.y = e.clientY;&#125;; window.onmouseout = function (e) &#123; mouse.x = null; mouse.y = null; &#125;;&#125; 知道鼠标坐标后，还要计算粒子到鼠标的距离,这里用到的Math.sqrt()是开根号，里面是用勾股定理算出粒子到鼠标的距离。第二个函数是获取粒子到鼠标的角度，知道角度后就能进行正交分解出粒子的x、y轴速度，这样就能让粒子向鼠标靠拢。 123456function getDistance(point, mouse) &#123; //获取粒子到鼠标的距离 return Math.sqrt(Math.pow(point.x-mouse.x,2) + Math.pow(point.y-mouse.y,2))&#125;function getTractiveAngle(point, mouse) &#123; //获取粒子到鼠标的距离 return Math.atan2(mouse.y - point.y, mouse.x - point.x)*180/Math.PI;&#125; 接下来要让画面动起来1234567891011function loop() &#123; //回调函数，循环 ctx.clearRect(0,0,w,h); remove(); createParticle(); for (var i = 0; i &lt; particle.length; i++) &#123; particle[i].updata(); particle[i].lifeUpdata(); particle[i].draw(); &#125; requestID = window.requestAnimationFrame(loop);&#125; 最后就是粒子开关 123456789101112var buttonParticle = document.getElementById(\"buttonParticle\"); //粒子开关buttonParticle.onclick = function () &#123; if (stoped) &#123; window.cancelAnimationFrame(requestID); ctx.clearRect(0, 0, w, h); console.log(\"stop\"); stoped = false; &#125;else if (!stoped) &#123; requestID = window.requestAnimationFrame(loop); stoped = true; &#125;&#125; 这样就快大功告成了，最后再加一些初始化和调用就可以了~最后附上完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179var canvas = document.getElementById(\"canvas\");var ctx = canvas.getContext(\"2d\");//将canvas画布设置成浏览器大小function getSize() &#123; w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight;&#125;//定义粒子var opt = &#123; particleDelay: 10, //粒子生成延时 particleLife: 500, //粒子存活时间 particleAmount: 50, //粒子数量 defaultSpeed: 0.5, //粒子初始运动速度 variantSpeed: 1, //粒子运动速度改变量 defaultAlpha: 0.7, //粒子不透明度 variantAlpha: 0.3, //粒子不透明度改变量(0~1) particleColor: \"rgba(32,245,245,\", //粒子颜色 defaultRadius: 2, //粒子半径 variantRadius: 2, //粒子半径改变量 tractiveRange: 100, //鼠标牵引范围&#125;function Particle() &#123; this.x = Math.random()*w; //粒子的x坐标 this.y = Math.random()*h; //粒子的y坐标 this.life = opt.particleLife; //粒子存活时间 this.currentLife = 0; //当前粒子存活时间 this.currentAlpha = 0; //当前粒子不透明度 this.alpha = opt.defaultAlpha - (Math.random() * opt.variantAlpha); //粒子不透明度 this.tempAlpha = (this.alpha/2) * (5/this.life); //按生存时间分割不透明度 this.speed = opt.defaultSpeed + opt.variantSpeed*Math.random(); //粒子运动速度 this.directionAngle = Math.floor(Math.random()*360); //返回一个0-360的整数 if (this.alpha &lt; 0) &#123; this.alpha = 0; &#125; this.radius = opt.defaultRadius + opt.variantRadius*Math.random(); //粒子半径 this.vector = &#123; x:this.speed * Math.cos(this.directionAngle), //x轴上的速度 y:this.speed * Math.sin(this.directionAngle) //y轴上的速度 &#125;; this.lifeUpdata = function () &#123; //生命周期函数 if (this.currentLife &lt;= (this.life / 4)) &#123; this.currentAlpha += this.tempAlpha; &#125;else if (this.currentLife &gt;= (this.life / 4) &amp;&amp; this.currentLife &lt;= (this.life * 3 / 4))&#123; this.currentAlpha = this.alpha; &#125; else if (this.currentLife &gt;= (this.life * 3 / 4)) &#123; this.currentAlpha -= this.tempAlpha; &#125; this.currentLife++; &#125;; this.updata = function () &#123; //更新数据 this.border(); //边缘检测 this.mouseTractive(); this.x += this.vector.x; this.y += this.vector.y; &#125;; this.border = function () &#123; //边缘检测 if (this.x + this.radius &gt;= w || this.x - this.radius &lt;= 0) &#123; //检测粒子触碰左右边界 this.vector.x *= -1; &#125; if (this.y + this.radius &gt;= h || this.y - this.radius &lt;= 0) &#123; //检测粒子触碰上下边界 this.vector.y *= -1; &#125; if(this.x &gt; w) &#123; //改变窗口大小时显示出粒子 this.x = w; &#125; if(this.y &gt; h) &#123; this.y = h; &#125; &#125;; this.draw = function () &#123; //绘制粒子 this.color = opt.particleColor + this.currentAlpha + \")\"; //粒子颜色 ctx.beginPath(); //开始一条路径 ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); //画圆 ctx.closePath(); ctx.fillStyle = this.color; ctx.fill(); //填充 ctx.shadowBlur = 20; ctx.shadowColor = this.color; &#125;; this.mouseTractive = function () &#123; //鼠标牵引 mouseXY(); if (getDistance(this,mouse) &lt;= opt.tractiveRange) &#123; this.vector = &#123; x:this.speed * Math.cos(getTractiveAngle(this,mouse)), //x轴上的速度 y:this.speed * Math.sin(getTractiveAngle(this,mouse)) //y轴上的速度 &#125;; &#125; &#125;&#125;function remove() &#123; //清除粒子 for (var i = 0; i &lt; particle.length; i++) &#123; if (particle[i].currentLife &gt;= particle[i].life) particle.shift(); &#125;&#125;function createParticle() &#123; //生成粒子 if(particle.length &lt; opt.particleAmount) &#123; if(t &gt;= opt.particleDelay) &#123; particle.push(new Particle()); t = 0; &#125; t++; &#125;&#125;function init() &#123; //绘制粒子 getSize(); loop();&#125;var mouse = &#123; x: null, y: null&#125;;function mouseXY() &#123; window.onmousemove = function (e) &#123; //获取鼠标坐标 e = e || window.event; mouse.x = e.clientX; mouse.y = e.clientY;&#125;; window.onmouseout = function (e) &#123; mouse.x = null; mouse.y = null; &#125;;&#125;function getDistance(point, mouse) &#123; //获取粒子到鼠标的距离 return Math.sqrt(Math.pow(point.x-mouse.x,2) + Math.pow(point.y-mouse.y,2))&#125;function getTractiveAngle(point, mouse) &#123; //获取粒子到鼠标的距离 return Math.atan2(mouse.y - point.y, mouse.x - point.x)*180/Math.PI;&#125;//-----------------------------------------------//function loop() &#123; //回调函数，循环 ctx.clearRect(0,0,w,h); remove(); createParticle(); for (var i = 0; i &lt; particle.length; i++) &#123; particle[i].updata(); particle[i].lifeUpdata(); particle[i].draw(); &#125; requestID = window.requestAnimationFrame(loop);&#125;var buttonParticle = document.getElementById(\"buttonParticle\"); //粒子开关buttonParticle.onclick = function () &#123; if (stoped) &#123; window.cancelAnimationFrame(requestID); ctx.clearRect(0, 0, w, h); console.log(\"stop\"); stoped = false; &#125;else if (!stoped) &#123; requestID = window.requestAnimationFrame(loop); stoped = true; &#125;&#125;var particle = [];var delay = 200; //设置延时var w,h,t=0;var requestID;var stoped = false;init();window.cancelAnimationFrame(requestID); 最后效果还是很满意的，动图好像有点问题，这里就放个静态图吧(。・∀・)ノ","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"正则表达式","slug":"web","date":"2018-08-05T14:29:53.000Z","updated":"2018-10-22T13:52:44.758Z","comments":true,"path":"2018/08/05/web/","link":"","permalink":"http://yoursite.com/2018/08/05/web/","excerpt":"","text":"因为之前遇到不少正则表达式，我对这理解不深，还是有很多小问题，所以打算重新理解。 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE） 概念正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 目的 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”） 可以通过正则表达式，从字符串中获取我们想要的特定部分。 特点 灵活性，逻辑性和功能性特别强 可以迅速地用极其简单的方式达到字符串的复杂控制 语法 runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次） runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次） colou?r，可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次） 贪婪与非贪婪 贪婪匹配：在整个表达式匹配成功的前提下，尽可能多的匹配。 非贪婪匹配：在匹配优先量词后加上？，在整个表达式匹配成功的前提下，尽可能少的匹配。 例子 字符串“yeeeeeeee”，使用ye.*匹配，结果为yeeeeeeee 字符串“yeeeeeeee”，使用ye.*?匹配，结果为ye Chapter [1-9][0-9]*，限定符出现再范围表达式之后，应用于整个范围表达式。匹配任何位数的章节标题，如“Chapter 1”、“Chapter 10”、“Chapter 123” Chapter [1-9][0-9]?，只匹配1~99的章节，等同于Chapter [1-9][0-9]{0,1}，如“Chuapter 1”、“Chuapter 99” 表达式全集 引用自百度百科 参考资料 正则表达式 – 语法 | 菜鸟教程 正则表达式_百度百科 正则表达式之 贪婪与非贪婪模式详解（概述）_正则表达式 - 阿里云","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"第一篇文章","slug":"diary","date":"2018-07-25T17:50:20.000Z","updated":"2018-07-25T18:32:11.966Z","comments":true,"path":"2018/07/26/diary/","link":"","permalink":"http://yoursite.com/2018/07/26/diary/","excerpt":"","text":"这是我的第一篇文章，昨晚看到一篇关于如何搭建个人博客的文章”hexo从零开始到搭建完整“，看到后瞬间引起了我极大的兴趣。挺久之前我就有想着能拥有自己的个人博客，能把平时在网上看到的各种有趣的技术记录下来，也能记录自己的学习过程（有点日记的感觉？） 最近在重新复习CSS,js ,html尝试着仿京东的网页布局，曾经以为自己非常熟练的知识，再运用一次又发现了许多小技巧。 这段时间遇到了许多不愉快的事情。还是需要静下心来，找清楚方向，一步一步向前。","categories":[],"tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]}]}